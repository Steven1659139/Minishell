
[X] Afficher un prompt en l’attente d’une nouvelle commande.
[X] Historique fonctionnel
[] chercher et lancer le bon exécutable (PATH environnement, absolu ou relatif)
[] ne pas interprèter de quotes non fermés ou de caractère spéciaux non préciser comme \ ou ;
[X] gérer simple quotes
[X] gérer double quotes


[] redirections 
	[X] "< doit rediriger l'entrée"
	[X] > doit rediriger la sortie 
	[X] << doit recevoir un délimiteur et lire l’input donné jusqu’à rencontrer une ligne contenant le délimiteur. Cependant, l’historique n’a pas à être mis à jour !
	[X] >> doit rediriger la sortie en mode append.

[] execution
	[X] Fonction find_path_for command. Ajoute le fin que si la comande est deja un executable, le garder tel quel. 
	[] Si jai un error_infile pcq infile nexiste pas, ne pas creer de child et simplement afficher sur STDERR le message
	[] 1 ligne de commande avec builtin (manque seulement que les builtin soient finis pour les tester)
	[X] 1 ligne de commande avec commande
	[] Tester
	[] 2 lignes de commands (1 builtin, 1 pipe, 1 command)
	[] 2 lignes de commands (1 commande, 1 pipe, 1 builtin)
	[] Cas d'erreur!.' 
	[] gérer les paths absolu
	[] exécutable
	[] changer la facon dont les waitpid fonctionne et les regrouper tous en dehors de la fonction create_child
	[] gerer le cas  cat > test.txt | wc
	[] valider que tous les fds sont bien ferme (est ce que je dois regarder dans les childs aussi)
	[] activer les signaux Ctrl+C et Ctrl + \ dans les childs (ai je le droit)
	[] ./minishell | 

	FIXME: [X] les builtins sont exécutée puis renvoie l'erreur' command not found ex: bash: echo: command not found


[<] implémenter les pipes ( | )
[X] Gérer les variables d’environnement (un $ suivi d’une séquence de caractères) qui doivent être substituées par leur contenu.
[] Gérer $? qui doit être substitué par le statut de sortie de la dernière pipeline exécutée au premier plan.


[] signaux
	[] ctrl-C
	[] ctrl-D
	[] ctrl-\
[] Builtins
	[] echo et "l'option -n"
		[] echo "" ''
		[X] gérer -n avec autre chose que juste n
		[X] gérer plusieurs -n 
		[X] gérer les cas de allo"allo""allo" fait: allo"allo""allo" devrait faire : alloalloallo
		[X] gérer "'" '"' dans écho
		[] gestion d'erreur'
	[X] cd uniquement avec un chemin relatif ou absolu
		[X]	cd ..
		[X]	cd invalid
		[X]	cd ...
		[X]	cd sans argument retour à la racine 
		[X] gestion d'erreur'
	[X] pwd sans aucune option
		[X] pas de pwd 
	[] export sans aucune option
		[X] export sans argument
		[X] gérer plusieurs args
		[X] pas de "="
		[] vérifier si la variable existe déjà
		[X] gestion des erreurs
	[] unset sans aucune option
		[X] gérer plusieurs args
		[X] gérer les "="
		[X] sans argument
	[] env sans aucune option ni argument
		[] renvoyer une erreur s'il' il des arguments ?
		[] gestion d'erreur'
	[] exit sans aucune option
		[] errno
		[] gestion d'erreur'


[] gérer le $
	[] "$U'SE'R" doit supprimer $U	
	[] supprimer tous les $
	[] fix les cas de "$USER" "'$USER'" '$USER'
	
[] Heredocs
	[] Discussion avec plus de chevrons <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	[] heredoc ne fonctionne pas collé au delim. ex :cat <<delim
	[X] heredoc ferme si le delim se retrouve au debut de la ligne 
		ex:	$> cat << hello
			>	hello my name is
			$>
	[] heredoc ne fonctionne pas avec les fonctions execve

[] gérer le errno

Struct
	[X] char **environnement


TODO: 
	
	
		

FIXME:
		[X] unset
		[X] trunc les espaces après
		[X] unset PATH fait segfault fill_cmd
		[] double le prompt quand ctrl-C lorsque que le minishell hang
		[X] gérer les quotes vides "" '' pense que les quotes ne sont pas fermés




Question: 
			- est-ce qu'on' laisse passé les args d'export' avec des espaces ex: "export allo = 12345"       Réponse: non 
 		
LOG:
	Steven	31 octobre:	- gérer les différents cas des pipes aves espaces
						- trunquer les espaces devant les commandes suivant les pipes
						- ne pas interprèter les pipes entre quotes
						- state machine 
						- ne pas interprèter les quotes non-fermés
						- fix cd ..
						- fix remove_quote
																										
	Steven 2 novembre:	- fix double free in reinit
						- revenir au début si les quotes ne sont pas fermés
	
	Steven 5 novembre: 	- set readline 
						- fix -n multiple -ndasfsgd -nnnnnnnn
						- fix commande avec suivis d'autre' caractère ex: echo123
						- plus de leaks dans la redirection pour le moment
						- cd ..
						- cd gestion d'erreur'
						- nouvelle façon de gérer pwd
						- fix unset pwd
						

	Steven 7 novembre:	- fix edge case pwd 
						- fix segfault unset sans argument
						- 

	Steven 8 novembre:	- fix export plusieurs argument
						- fix export sans "="
						- gestion d'erreur' export
						- fix unset sans argument 
						- unset avec plusieurs args
						- fix unset avec "=" 

	Steven 9 novembre:	- fix quotes fermés quand elles sont vides ex: "" ou ''
						- fix echo "" et ''
						- fonction qui supprime les tokens vides



test redirection:
					- <>		bash = bash: syntax error near unexpected token 'newline'
					- <\>		bash = bash: >: No such file or directory

test général:
				- vérifier comment se comporte le code lorsque l'on' unset une variables importantes, ex: PATH ou PWD
				- sleep(2) | sleep(2) | sleep(2	)
				- dev/urandom


test echo:
			- echo <|>					bash = bash: syntax error near unexpected token '|'								
			- echo allo			OK
			- echo "allo" 		OK 
			- echo 'allo' 		OK
			- echo "'allo'" 	OK
			- echo '"allo"' 	OK
			- echo '"a"ll"o"' 	OK
			- echo '"a"ll"o"' 	OK
			- echo				


[X] Afficher un prompt en l’attente d’une nouvelle commande.
[X] Historique fonctionnel
[X] chercher et lancer le bon exécutable (PATH environnement, absolu ou relatif)
[X] ne pas interprèter de quotes non fermés ou de caractère spéciaux non préciser comme \ ou ;
[X] gérer simple quotes
[X] gérer double quotes


[X] redirections 
	[X] Modifer fonction heredoc pour pipe au lieu de fichier.
	[X] << allo cat, ne reconnait pas le delimiter s'il y a un espace après
	[X] >> créer les fichiers en concervant les espaces
	[X] "< doit rediriger l'entrée"
	[X] > doit rediriger la sortie 
	[X] << doit recevoir un délimiteur et lire l’input donné jusqu’à rencontrer une ligne contenant le délimiteur. Cependant, l’historique n’a pas à être mis à jour !
	[X] >> doit rediriger la sortie en mode append.

[] execution
	[X] 2 lignes de commands (1 builtin, 1 pipe, 1 command)
	[X] 2 lignes de commands (1 commande, 1 pipe, 1 builtin)
		FIXME: 
				[X] ex: cat | ls, cat attend, mais quitte a la premiere entrée


	[X] activer les signaux Ctrl+C et Ctrl + \ dans les childs (ai je le droit)
	[] Cas specifique a gerer 
		[X] Gerer les path relatifs?
		[X] Tous les FDS fermes dans parent (et aussi child?).
		[X] gerer le cas  cat > test.txt | wc
	[X] Infile error : affichesur stderr durant letape execution (Nouvelle fonction: exec_error_manangement )
	[X] Cmd error : afficher sur stderr durant execiton (Nouvelle fonction: exec_error_manangement )
	[X] Fonction find_path_for command. Ajoute le fin que si la comande est deja un executable, le garder tel quel. 
	[X] 1 ligne de commande avec builtin (manque seulement que les builtin soient finis pour les tester)
	[X] 1 ligne de commande avec commande
	[X] Gerer les executables dont donne le path complet (ex: /bin/ls)
	[X] ./minishell |
	[X] Execution en simultaneeO (waitpid en dehors de la fonction create_child)

	FIXME: [X] les builtins sont exécutée puis renvoie l'erreur' command not found ex: bash: echo: command not found


[X] implémenter les pipes ( | )
[X] Gérer les variables d’environnement (un $ suivi d’une séquence de caractères) qui doivent être substituées par leur contenu.
[X] Gérer $? qui doit être substitué par le statut de sortie de la dernière pipeline exécutée au premier plan.

[X] signaux
	[X] ctrl-C
	[X] ctrl-D
	[X] ctrl-\

FIXME:	
		[X] ctrl-C double le prompt lorsque le programme hang

[] Builtins
	[X] echo et "l'option -n"
		[X] echo "" ''
		[X] gérer -n avec autre chose que juste n
		[X] gérer plusieurs -n 
		[X] gérer les cas de allo"allo""allo" fait: allo"allo""allo" devrait faire : alloalloallo
		[X] gérer "'" '"' dans écho
		[X] gestion d'erreur'
	[X] cd uniquement avec un chemin relatif ou absolu
		[X]	cd ..
		[X]	cd invalid
		[X]	cd ...
		[X]	cd sans argument retour à la racine 
		[X] gestion d'erreur'
	[X] pwd sans aucune option
		[X] pas de pwd 
	[X  ] export sans aucune option
		[X] export sans argument
		[X] gérer plusieurs args
		[X] pas de "="
		[X] var1, var111111111
		[X] vérifier si la variable existe déjà
		[X] gestion des erreurs
	[X] unset sans aucune option
		[X] gérer plusieurs args
		[X] gérer les "="
		[X] sans argument
		FIXME:
				[X] l'utilisation de unset et export créer parfois un segfault, diffile à reproduire, mais doit venir des strlcpy à vérifier avec valgrind

	[X] env sans aucune option ni argument
		[X] renvoyer une erreur s'il' il des arguments ?
		[X] gestion d'erreur'
	[] exit sans aucune option
		[X] errno
		[X] gestion d'erreur'


[] gérer le $
	[X] "$U'SE'R" doit supprimer $U	
	[X] supprimer tous les $ seul
	[X] fix les cas de "$USER" "'$USER'" '$USER'
	
[X] Heredocs
	[X] Changer heredoc pour utiliser un pipe au lieu de fichier 
	[X] Discussion avec plus de chevrons <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	[X] heredoc ne fonctionne pas collé au delim. ex :cat <<delim
	[X] heredoc ferme si le delim se retrouve au debut de la ligne 
		ex:	$> cat << hello
			>	hello my name is
			$>
	[X] heredoc ne fonctionne pas avec les fonctions execve

[X] gérer le errno

Struct
	[X] char **environnement


TODO: 
		[X] fonction update state baser sur deux flag D_quote et S_quote déterminant quoi faire avec le contenue d'une expansion
		[X] fix l'espace de la destination de export
		[X] réduire le main
		[X] répartir les fonctions du main dans différents fichiers
		[X]réduire find_expansion
		[X] clean up minishell.h 
		[X] changer les printf pour la sortie d'erreurs
		[X] gérer la premiere commande différamment, passer à éviter les erreurs avec les Heredocs si la commande n'est pas la première chose

		[X] |
		[X] ||||
		[X] <
		[X] <<
		[X] <<<
		[X] >
		[X] >>
		[X] >>>
		[] <|>
		[] < a | >> gfdghd
		[] < a | > gfdghd
		[] < a | >>
		[] < a | >

test:
		|			Nous = bash: syntax error near unexpected token `|'											bash = bash: syntax error near unexpected token `|'
		||||||		Nous = bash: syntax error near unexpected token `|'											bash = bash: syntax error near unexpected token `||'
		<			Nous = bash: syntax error near unexpected token `newline'									bash = bash: syntax error near unexpected token `newline'
		<<			Nous = bash: syntax error near unexpected token `newline'									bash = bash: syntax error near unexpected token `newline'
		<<<			Nous = bash: syntax error near unexpected token '<'											bash = bash: syntax error near unexpected token `newline'
		>			Nous = bash: syntax error near unexpected token `newline'									bash = bash: syntax error near unexpected token `newline'
		>>			Nous = bash: syntax error near unexpected token `newline'									bash = bash: syntax error near unexpected token `newline'
		>>>			Nous = bash: syntax error near unexpected token '>'											bash = bash: syntax error near unexpected token `>'
		<>			Nous = bash: >: No such file or directory													bash = bash: syntax error near unexpected token `newline'    FIXME: traite le dernier chevrons 
		<> | <>		Nous = bash: syntax error near unexpected token '|'											bash = bash: syntax error near unexpected token `|'
		< | <		Nous = bash: syntax error near unexpected token '|'											bash = bash: syntax error near unexpected token `|'
		<< | <<		Nous = 	bash: syntax error near unexpected token '|'										bash = bash: syntax error near unexpected token `|'
		<<< | <<<	Nous = bash: syntax error near unexpected token '<'											bash = bash: syntax error near unexpected token `|'  TOKNOW: C'est correct on traite le <<< en premier
		> | > 		Nous = bash: syntax error near unexpected token '|'											bash = bash: syntax error near unexpected token `|'
		>> | >>		Nous = bash: syntax error near unexpected token '|'											bash = bash: syntax error near unexpected token `|'
		>>> | >>>	Nous = bash: syntax error near unexpected token '>'											bash = bash: syntax error near unexpected token `|'
		echo <|>	Nous = bash: syntax error near unexpected token '|'											bash = bash: syntax error near unexpected token `|'
		echo <>		Nous = bash: >: No such file or directory FIXME: le programme quitte dans le parent			bash = bash: syntax error near unexpected token `newline'
		echo |		Nous = bash: syntax error near unexpected token `newline'									bash = 	
		echo |||	Nous = bash: syntax error near unexpected token `|'	
		echo <> allo Nous = bash: >: No such file or directory et bash fonctionne, il lit dans le fichier qui viens d'être créer, on devrais s'en crisser

		echo | ls > Nous = ne créer pas d'erreur
		< a | 
		< a | > b
		> j | < a   fichier existe
		> j | < b   fichier n'existe pas



Cesar:
- Gerer les bons exit_code. Si j'appelle 2 fois de suite echo $? cela va afficher 0 la deuxieme fois. 
- Gestion des cas d'erreurs dans les builtin. 
- cd <mauvais path>  = echo $? devrait afficher code 1


FIXME:
		[X] unset
		[X] trunc les espaces après
		[X] unset PATH fait segfault fill_cmd
		[X] double le prompt quand ctrl-C lorsque que le minishell hang
		[X] gérer les quotes vides "" '' pense que les quotes ne sont pas fermés
		[X] les builtins en même temps que les commandes
		[X] ne pas expande le délimiteur des Heredocs
		[X] expand les variables dans les Heredocs
		[X] cat <<< hello --> affiche un erreur mais lance la commande.
		[X] ls"2" devrait error --> ls2 : not found
		[X] ca"t" devrait succeed
		[X] export plusieurs variables
		[X] export ne peux pas commencer par un nombre 
		[X] ne peux pas commence par autre chose qu'une lettre ou un _
		[X] echo "bon"jour""
		[X] unset path segfault
		[X] echo allo>file
		[X] <file wc -l
		[X] remettre la static à zéro
		[X] invalid read Heredocs
		[X] expand après la condition
		[] bash: syntax error near unexpected token `newline' si << sans rien comme argument
		[X] CTRL C heredoc
		[X] argument exit
		[] export lol2="hello steven"
		[] command 3 ne fontionne pas

		[X] expansion ne fontionne plus après un cas qui n'existe' pas 
		[X] builtins majuscule passe dans execve 
		[] echo "allo""allo2" skip parfois le premier caractère du deuxième token, probablement en lien avece un invalid read 
		[] double free quote seule 
		[X] espace devant les fichier ex: > test.txt
		[] expansion ne fontionne plus après un cas qui n'existe' pas 

LEAKS:
		FIXME:
				reste beaucoup de FDS ouvert

 
				
<< allo
> asdf
> gfds
> fds
> $USER
> 
				arriver dans un heredocs 

				==30221== Invalid read of size 1
==30221==    at 0x100008937: if_exit_code (utils_expansion.c:64)
==30221==    by 0x100008520: locate_expansion (var_expansion.c:49)
==30221==    by 0x100006A0F: delimiter_finder (redirection.c:61)
==30221==    by 0x100006AF6: heredoc_redirection (redirection.c:82)
==30221==    by 0x100006C62: search_for_redirection (redirection.c:108)
==30221==    by 0x1000041EA: routine (main.c:97)
==30221==    by 0x100004315: main (main.c:129)
==30221==  Address 0x10098a0c1 is 0 bytes after a block of size 1 alloc'd
==30221==    at 0x100180545: malloc (in /Users/slavoie/.brew/Cellar/valgrind/HEAD-6ff08b6/libexec/valgrind/vgpreload_memcheck-amd64-darwin.so)
==30221==    by 0x1000359E0: ft_calloc (ft_calloc.c:19)
==30221==    by 0x100034965: ft_strjoin (ft_strjoin.c:21)
==30221==    by 0x10000413B: take_input (main.c:77)
==30221==    by 0x10000695A: delimiter_finder (redirection.c:48)
==30221==    by 0x100006AF6: heredoc_redirection (redirection.c:82)
==30221==    by 0x100006C62: search_for_redirection (redirection.c:108)
==30221==    by 0x1000041EA: routine (main.c:97)
==30221==    by 0x100004315: main (main.c:129)




Question: 
			- est-ce qu'on' laisse passé les args d'export' avec des espaces ex: "export allo = 12345"       Réponse: non 
 		
LOG:
	Steven	31 octobre:	- gérer les différents cas des pipes aves espaces
						- trunquer les espaces devant les commandes suivant les pipes
						- ne pas interprèter les pipes entre quotes
						- state machine 
						- ne pas interprèter les quotes non-fermés
						- fix cd ..
						- fix remove_quote
																										
	Steven 2 novembre:	- fix double free in reinit
						- revenir au début si les quotes ne sont pas fermés
	
	Steven 5 novembre: 	- set readline 
						- fix -n multiple -ndasfsgd -nnnnnnnn
						- fix commande avec suivis d'autre' caractère ex: echo123
						- plus de leaks dans la redirection pour le moment
						- cd ..
						- cd gestion d'erreur'
						- nouvelle façon de gérer pwd
						- fix unset pwd
						

	Steven 7 novembre:	- fix edge case pwd 
						- fix segfault unset sans argument
						- 

	Cesar 7 novembre 	- Gerer les absolute path dans la fonction find_path_of_command
						- Modif find_path_command pour eviter que builtin "echo" ou autre ne cherche son executable (ex: bin/echo);
						- Input redirection(1ere serie de commande) et output redirection (derniere serie de commande) fonctionnel. 
						- Creation fonction one_command_or_builtin (pour execution un seule command ou builtin)
						- Ajout initial_stdin et initial_stdin dans fonction init() et reinit();
						- Creation fonction, put_back_initial_std (pour remettre les stdin a leur etat initial)
						- Execution en simultanee (waitpid en dehors de la fonction create_child)

	Steven 8 novembre:	- fix export plusieurs argument
						- fix export sans "="
						- gestion d'erreur' export
						- fix unset sans argument 
						- unset avec plusieurs args
						- fix unset avec "=" 

	Cesar 8 novembre 	- Infile error: message d'erreur STDERR s'affiche lors de l'execution (ex : < te.txt cat | wc)
						- Refait les fonctions dans execution pour que ca soit plus lisible  

	Steven 9 novembre:	- fix quotes fermés quand elles sont vides ex: "" ou ''
						- fix echo "" et ''
						- fonction qui supprime les tokens vides
						- fix espaces et doubles chevrons ex: >>allo ou <<allo

	Cesar 9 novembre    - Modifier fonction heredoc pour un pipe.
						- Changer strncmp dans fonction redirection pour strncmp(<<, 3) et strncmp(< , 2)
						- Cas suivant fonctionne : < test.txt | wc   OU  << cat (Modification fonction create_execve_args_list)
	

	Cesar 10 novembre	- Modification des waitpid dans la fonction create_child
						- 

	Steven 11 novembre	- fix export 
						- fix command seule, manquait un waitpid
						- fix espaces après le delimiter des Heredocs
						- fix espaces après les noms de fichiers générer par >>

	Cesar 13 novembre   - Gestion du cas cat > test2.txt | wc  pour qu'il reagisse comme dans bash 
						- Gestion des de input redirection dans les lignes commandes autre que 1ere! 
						- Cleaner ma fonction find_execve_binary 
						- Ajout du fichier temporary.c qui contient des fonctions qui fonctionnaient avant qu'elle ne soit
						  epuree (Just in case!)

	Cesar 14 novembre   - Expansion non-existante (Ex: TRES) n'affiche rien et retourne le prompt
						- Message derreur lorsque redirection avec expansion non-existante (< TRES) (Ajout else if dans fonction exec_error_management)
						- Message derreur lorsque redirection avec fichier non-existante (ex: < te.txt) (Ajout else if dans fonction exec_error_management)
	
	Cesar 15 novembre   - Commande non-existante affiche exit code 127 
						- Incorrect input affiche code 1  
						- Rendu ma fonction execution plus courte pour respecter les 25 lignes  
						- Changer le nom de certains arguments dans ma strucuture t_command_line
							-Cmd_and _args = path 
							-Merge_path_cmd = argv 
							-function "execve_error_management" s'appele check_if_error


	Cesar 16 novembre   - Fix : mon message d'erreur command not found ne s'affiche plus.
						- Fix : Regler le cas echo Cesar > test2.txt | wc qui causait un command not found pour echo 
						- Fix : Regler le problemes des 2 minishell  Minishell> Minishell> lorsqu'on fait Ctrl+C
						  (Regler avec l'ajout de la fonction signal(SIGINT, &signal_child) dans la fonction execution.c 
						- Regler les codes d'erreurs des signaux (SIGINT et SIQUIT)
						- Regler probleme de command ' << Cesar ' seul. Il manquait une protection dans table_flip

	Cesar 17 novembre   - Fix: regler le probleme de ' cat /dev/urandom | head -3
						- Creer fonction get_exit_code (Elle se trouve dans signal.c)
						- Desactiver echo pour que Ctrl+C n'affiche pas ^C, mais lorsque dans child il s'affiche

	Cesar 18 novembre	- Arranger le cas du initial_stdin et initial_stdout
						- Modifier ma fonction execution pour eviter segfault dans heredoc (a retravailler)

test redirection:
					- (DONE) <>		bash = bash: syntax error near unexpected token 'newline'
					- (DONE) <\>	bash = bash: >: No such file or directory . (Cesar: Il me semble que c'est le meme message qu'en haut dans ce cas)

test général:
				- vérifier comment se comporte le code lorsque l'on' unset une variables importantes, ex: PATH ou PWD
				- (VALIDE) sleep(2) | sleep(2) | sleep(2)
				- (VALIDE) dev/urandom


test echo:  TOUS MIS DANS TEST sauf le premier 
			- (A FAIRE) echo <|>					bash = bash: syntax error near unexpected token '|'								
			- echo allo			OK
			- echo "allo" 		OK 
			- echo 'allo' 		OK
			- echo "'allo'" 	OK
			- echo '"allo"' 	OK
			- echo '"a"ll"o"' 	OK
			- echo '"a"ll"o"' 	OK
			- echo				OK 	


echo Cesar > test2.txt | wc

==69891== 8 bytes in 1 blocks are still reachable in loss record 3 of 117
==69891==    at 0x100180545: malloc (in /System/Volumes/Data/sgoinfre/Perso/cemenjiv/.brew/Cellar/valgrind/HEAD-6ff08b6/libexec/valgrind/vgpreload_memcheck-amd64-darwin.so)
==69891==    by 0x100035960: ft_calloc (ft_calloc.c:19)
==69891==    by 0x1000050B6: multiple_commands_or_builtins (execution.c:90)
==69891==    by 0x10000522D: execution (execution.c:124)
==69891==    by 0x100003CF5: routine (main.c:104)
==69891==    by 0x100003E35: main (main.c:137)

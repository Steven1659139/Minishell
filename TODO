
[X] Afficher un prompt en l’attente d’une nouvelle commande.
[X] Historique fonctionnel
[] chercher et lancer le bon exécutable (PATH environnement, absolu ou relatif)
[] ne pas interprèter de quotes non fermés ou de caractère spéciaux non préciser comme \ ou ;
[X] gérer simple quotes
[X] gérer double quotes


[] redirections 
	[X] "< doit rediriger l'entrée"
	[X] > doit rediriger la sortie 
	[X] << doit recevoir un délimiteur et lire l’input donné jusqu’à rencontrer une ligne contenant le délimiteur. Cependant, l’historique n’a pas à être mis à jour !
	[X] >> doit rediriger la sortie en mode append.

[] execution
	[] 1 ligne de commande avec builtin
	[] 1 ligne de commande avec commande
	[] Tester
	[] 2 lignes de commands (1 builtin, 1 pipe, 1 command)
	[] 2 lignes de commands (1 commande, 1 pipe, 1 builtin)
	[] Cas d'erreur!.' 
	[] gérer les paths absolu

	FIXME: [] les builtins sont exécutée puis renvoie l'erreur' command not found ex: bash: echo: command not found


[] implémenter les pipes ( | )
[X] Gérer les variables d’environnement (un $ suivi d’une séquence de caractères) qui doivent être substituées par leur contenu.
[] Gérer $? qui doit être substitué par le statut de sortie de la dernière pipeline exécutée au premier plan.


[] signaux
	[] ctrl-C
	[] ctrl-D
	[] ctrl-\
[] Builtins
	[] echo et "l'option -n"
		[] gérer -n avec autre chose que juste n
		[] gérer plusieurs -n 
		[X] gérer les cas de allo"allo""allo" fait: allo"allo""allo" devrait faire : alloalloallo
		[X] gérer "'" '"' dans écho
		[] gestion d'erreur'
	[X] cd uniquement avec un chemin relatif ou absolu
		[X]	cd ..
		[X]	cd invalid
		[X]	cd ...
		[X]	cd sans argument retour à la racine 
		[] gestion d'erreur'
	[X] pwd sans aucune option
		[] pas de pwd 
	[] export sans aucune option
		[X] export sans argument
		[] gérer plusieurs args
		[] gestion des erreurs
	[] unset sans aucune option
		[] gérer plusieurs args
		[] gérer les "="
	[X] env sans aucune option ni argument
		[] gestion d'erreur'
	[X] exit sans aucune option
		[] gestion d'erreur'




Struct
	[X] char **environnement


TODO: 
		[X] gérer les espaces entre les différents tokens avec des quotes
		[X] convertir la gestion de token en linked list
		[X] gérer le echo avec la nouvelle façon en linked list
		[] adapter $ pour qu'il' cherche dans la copie de l'environnement'
		[X] update le PWD dans l'env'
		[X] parser les listes et remplir les command_lines
		[X] ne pas compter les pipes entre quotes
		[X] state machine 
		[X] fix echo
		[] fix les cas de "$USER" "'$USER'" '$USER'
		
		

FIXME:
		[X] segfault lorsqu'il' y a des espaces devant la première commande, viens probablement de skip_space
		[X] segfault echo seul sans argument
		[X]	cd avec aucun argument doit ramener à la racine
		[X] node fucked up, je comprends rien WTF:
		[] refaire fonctionnner les builtins avec la nouvelle structure 
			[] cd
				[] .., trunc l'espace'
			[X] pwd
			[] echo
			[X] env
			[X] exit
			[] unset
			[X] export
		[] gérer les caractères après les commandes ex: echos, pwdttre, exite, etc.
		[] trunc les espaces après

Question: 
			- est-ce qu'on' laisse passé les args d'export' avec des espaces ex: "export allo = 12345"
 		
LOG:
	Steven	31 octobre:	- gérer les différents cas des pipes aves espaces
						- trunquer les espaces devant les commandes suivant les pipes
						- ne pas interprèter les pipes entre quotes
						- state machine 
						- ne pas interprèter les quotes non-fermés
						- fix cd ..
						- fix remove_quote
																										
	Steven 2 novembre:	- fix double free in reinit
						- revenir au début si les quotes ne sont pas fermés
						- 
